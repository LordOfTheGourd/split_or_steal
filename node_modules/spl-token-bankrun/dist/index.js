"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccount = exports.getSigners = exports.mintTo = exports.mintToOverride = exports.getMint = exports.createAssociatedTokenAccount = exports.createAccount = exports.createMint = void 0;
const web3_js_1 = require("@solana/web3.js");
const token = __importStar(require("@solana/spl-token"));
async function createMint(banksClient, payer, mintAuthority, freezeAuthority, decimals, keypair = web3_js_1.Keypair.generate(), programId = token.TOKEN_PROGRAM_ID) {
    let rent = await banksClient.getRent();
    const tx = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: keypair.publicKey,
        space: token.MINT_SIZE,
        lamports: Number(await rent.minimumBalance(BigInt(token.MINT_SIZE))),
        programId: token.TOKEN_PROGRAM_ID,
    }), token.createInitializeMint2Instruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
    [tx.recentBlockhash] = (await banksClient.getLatestBlockhash());
    tx.sign(payer, keypair);
    await banksClient.processTransaction(tx);
    return keypair.publicKey;
}
exports.createMint = createMint;
async function createAccount(banksClient, payer, mint, owner, keypair, confirmOptions, programId = token.TOKEN_PROGRAM_ID) {
    let rent = await banksClient.getRent();
    // If a keypair isn't provided, create the associated token account and return its address
    if (!keypair)
        return await createAssociatedTokenAccount(banksClient, payer, mint, owner, programId);
    // Otherwise, create the account with the provided keypair and return its public key
    const mintState = await getMint(banksClient, mint, confirmOptions?.commitment, programId);
    const space = token.getAccountLenForMint(mintState);
    const tx = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: keypair.publicKey,
        space,
        lamports: Number(await rent.minimumBalance(BigInt(space))),
        programId,
    }), token.createInitializeAccountInstruction(keypair.publicKey, mint, owner, programId));
    [tx.recentBlockhash] = (await banksClient.getLatestBlockhash());
    tx.sign(payer, keypair);
    await banksClient.processTransaction(tx);
    return keypair.publicKey;
}
exports.createAccount = createAccount;
async function createAssociatedTokenAccount(banksClient, payer, mint, owner, programId = token.TOKEN_PROGRAM_ID, associatedTokenProgramId = token.ASSOCIATED_TOKEN_PROGRAM_ID) {
    const associatedToken = token.getAssociatedTokenAddressSync(mint, owner, true, programId, associatedTokenProgramId);
    const tx = new web3_js_1.Transaction().add(token.createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
    [tx.recentBlockhash] = (await banksClient.getLatestBlockhash());
    tx.sign(payer);
    await banksClient.processTransaction(tx);
    return associatedToken;
}
exports.createAssociatedTokenAccount = createAssociatedTokenAccount;
async function getMint(banksClient, address, commitment, programId = token.TOKEN_PROGRAM_ID) {
    const info = await banksClient.getAccount(address, commitment);
    return token.unpackMint(address, info, programId);
}
exports.getMint = getMint;
// `mintTo` without the mintAuthority signer
// uses bankrun's special `setAccount` function
async function mintToOverride(context, destination, amount) {
    const banksClient = context.banksClient;
    const existingAccount = await getAccount(banksClient, destination);
    const { mint, owner } = existingAccount;
    const accData = Buffer.alloc(token.ACCOUNT_SIZE);
    token.AccountLayout.encode({
        mint,
        owner,
        amount,
        delegateOption: 0,
        delegate: web3_js_1.PublicKey.default,
        delegatedAmount: 0n,
        state: 1,
        isNativeOption: 0,
        isNative: 0n,
        closeAuthorityOption: 0,
        closeAuthority: web3_js_1.PublicKey.default,
    }, accData);
    await context.setAccount(destination, {
        data: accData,
        executable: false,
        lamports: 1000000000,
        owner: token.TOKEN_PROGRAM_ID,
    });
}
exports.mintToOverride = mintToOverride;
async function mintTo(banksClient, payer, mint, destination, authority, amount, multiSigners = [], programId = token.TOKEN_PROGRAM_ID) {
    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
    const tx = new web3_js_1.Transaction().add(token.createMintToInstruction(mint, destination, authorityPublicKey, amount, multiSigners, programId));
    [tx.recentBlockhash] = (await banksClient.getLatestBlockhash());
    tx.sign(payer, ...signers);
    return await banksClient.processTransaction(tx);
}
exports.mintTo = mintTo;
function getSigners(signerOrMultisig, multiSigners) {
    return signerOrMultisig instanceof web3_js_1.PublicKey
        ? [signerOrMultisig, multiSigners]
        : [signerOrMultisig.publicKey, [signerOrMultisig]];
}
exports.getSigners = getSigners;
async function getAccount(banksClient, address, commitment, programId = token.TOKEN_PROGRAM_ID) {
    const info = await banksClient.getAccount(address, commitment);
    return token.unpackAccount(address, info, programId);
}
exports.getAccount = getAccount;
